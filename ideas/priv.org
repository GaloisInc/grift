Summary of/thoughts on privileged ISA

* high-level
** putting stuff in semantics vs. simulation
In general, unless something is *really* easy to bake into the semantics and
there's a good reason for it (i.e. it's something that's clearly not supposed to
be implementation-defined), it is probably good practice to leave it out of the
semantics. For example, some CSRs are not required to be implemented but may be
hardwired to 0, but this is dependent on the particular CSR. In order to check
this in the semantics, we'd have to check the CSR address, and if it were equal
to one of the addresses that is optional, we'd have to have a mechanism to check
whether that particular CSR were implemented. In short, it'd be real hairy to
bake that into the semantics.

At any point in the future, it'd be simple enough to selectively push some
things to the semantics, but it's best to leave anything that's not clearly a
win out of it.
** traps
What exactly happens when a trap occurs, either interrupt or exception?

Without delegation:
- privilege is set to M
- mtval sometimes gets some information (bad address or instruction)
- mpp gets the previous privilege mode
- mepc gets the current pc
- mcause gets the isInterrupt bit and the corresponding exception code
- PC gets set according to mtvec
** CSR R/W-ness
In general, do we want to model the r/w-ness of a CSR in the semantics? It'd be
simple enough, since it's encoded in the high four bits, and we can compare that
against the privilege level. It would be somewhat like the hardwiring of x0 to
the constant 0.
** CSR Field R/W-ness
Assuming we want to model the above, we may also want to model the individual
fields read/write-ness.

* plan
** implement getting/setting CSRs
... in both semantics and csr* instructions. For now, we may punt on whether to
check permissions against the privilege level and the type of instruction, but
that's probably something we do want to model in the semantics. If a CSR does
not exist, we're supposed to throw an illegal instruction exception, but given
that implementations may be allowed to implement additional nonstandard CSRs, it
may not make sense to bake that into the semantics.
** implement traps in semantics
Follow MIT's semantics for this, which look mostly correct.
** implement certain CSRs in simulation
In particular, mtval, mpp, mepc, and mcause. Later we can define misa and
mstatus.
** Add SExt and UExt to extension hierarchy.
* misa

** # Bits : XLEN
** R/W
** Must be readable, but a value of zero can be returned to indicate it has not been implemented
** MXL field = native base ISA width
*** May be writable in implementations that support multiple base ISA widths
*** Effective XLEN in M-mode, /M-XLEN/, is given by MXL, or is fixed if misa is 0.
*** MXL is always set to widest supported ISA at reset.
*** If MXL < widest supported XLEN
**** operations must ignore source operand register bits above M-XLEN
**** and must sign-extend results to fill destination register
** Extensions field encodes presence of the standard extensions
*** We could model this by swapping out an instruction set with one that contains fewer instructions.
* mtime/mtimecmp
mtime and mtimecmp are 64-bit precision memory mapped. The idea is that mtimecmp
remains fixed, while mtime is a counter starting at 0. When mtime == mtimecmp, a
timer interrupt is thrown. I believe both registers are in fact writeable.

My feeling is that this should mainly be handled on the simulation side,
although we could provide a semantics for it as well.
