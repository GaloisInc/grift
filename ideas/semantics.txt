The following is an email I drafted to Joe but never sent because it was a
little pre-emptive.

****

Hey Joe,

Another thing I'm carefully considering is how to handle a situation like the
following. The JALR instruction has the following semantics:

jalr rd, offset(r1)

===>

let t = pc + 4; pc = (x[rs1] + sext(offset)) & ~1; x[rd] = t;

Both state assignments (to pc and x[rd]) depend on another (particularly when
rs1 == rd), and so if we are thinking of each line as being executed
independently of the other, the really is no way to denote this without a
temporary variable. The way I've conceived of representing situations like this
is by using the convention that *within an instruction*, every state component
on the right-hand side of an assignment denotes the value of that component
*prior to executing that instruction.* Hence, in my denotation, I would (and do)
write the above as

pc = (x[rs1] + sext(offset)) & ~1; x[rd] = pc + 4;

The pc on the second line refers to the original pc, not the modified one. There
is really no ordering on these two statements; they are to be thought of as one
collective monolithic state update.

This means that semantically, each instruction has to be considered an isolated
entity, and we can't just think of execution of an instruction stream as a
stream of smaller updates to the global state. We'd need temporary variables to
be able to think of it that way. So, it could impact our formalization of a
multiprocessor environment down the line.
